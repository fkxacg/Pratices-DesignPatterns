/**
 * 
 * 本项目基本实现了 Head First Design Patterns 一书中全部14种设计模式。
 * 一些复杂的例子及复合模式（将多个模式同时使用，非设计模式）没有实现。
 * 本项目只作为设计模式的基础练习记录，更详细的内容在书中。
 * 更深入的部分记录GoF设计模式部分（如果有的话）。
 * 
 * 
 * 实现列表：
 * 
 * 抽象工厂模式 Abstract Factory（提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类）
 * 适配器模式 Adapter（将一个类的接口，转换为期望的另一个接口）
 * 命令模式 Command（将命令作为一个对象进行传送）
 * 组合模式 Composite（以一致的方式处理个别对象以及对象的组合）
 * 装饰模式 Decorate（装饰者可以不断的包装装饰者或具体组件）
 * 外观模式 Facade（让接口更简单）
 * 工厂方法模式 Factory Method（定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个）
 * 迭代器模式 Iterator（提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示）
 * 观察者模式 Observer（当被观察者的状态改变后发送消息给所有的观察者）
 * 代理模式 Proxy（为另一个对象提供一个替身或占位符以访问这个对象）
 * 单例模式 Singleton（保证单例类只有一个实例）
 * 状态模式 State（允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类）
 * 策略模式 Strategy（将算法封装，使他们可以互相替换）
 * 模板方法模式 Template（定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现）
 * 
 * 
 * 适配器模式的jdk实现。
 * 装饰模式的jdk实现（io流）。
 * 观察者模式的jdk实现（util库提供的一种实现方法）。
 * 模板方法模式的jdk实现（swing的JFrame）。
 * 
 * 
 * 本书没有实现的模式（使用次数不及上面的模式）
 * 
 * 桥接模式 Bridge（不只改变实现，也改变抽象）
 * 生成器模式 Builder（封装一个产品的构造过程，并允许按步骤构造）
 * 责任链模式 Chain of Responsibility（让一个以上的对象有机会能够处理某个请求，请求会按顺序在多个对象中流动）
 * 蝇量模式 Flyweight（让某个类的一个实例能用来提供多个虚拟实例，用一个对象模拟出许多个相同对象，不占用内存）
 * 解释器模式 Interpreter（为语言创建解释器）
 * 中介者模式 Mediator（集中相关对象之间复杂的沟通和控制方式，使用中介者将逻辑集中控制）
 * 备忘录模式 Memento（让对象返回之前的状态，java中可使用序列化机制）
 * 原型模式 Prototype（创建实例很昂贵或复杂时，使用现有实例创建新实例）
 * 访问者模式 Visitor（对一个对象的组合增加新的能力，且封装并不重要）
 * 
 */
/**
 * @author fkxacg
 *
 */
package com.fkxacg.study.designpattern;